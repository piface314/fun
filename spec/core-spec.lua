describe('Fun', function()
  local fun, Fun

  setup(function()
    fun = require '.init'
    Fun = require '.core'
  end)

  describe('.is', function()
    it('should return true only for Fun objects', function()
      assert.is.True(Fun.is(fun {}))
      assert.is.False(Fun.is({}))
      assert.is.False(Fun.is(nil))
      assert.is.False(Fun.is(1))
    end)
  end)

  describe('.bind', function()
    it('should only accept tables', function()
      assert.has_no.errors(function() Fun.bind {} end)
      assert.has.error(function() Fun.bind(nil) end)
      assert.has.error(function() Fun.bind(1) end)
      assert.has.error(function() Fun.bind(true) end)
      assert.has.error(function() Fun.bind('1') end)
    end)
    it('should do a copy of the table if requested', function()
      local t1, t2 = {1, 2, 3}, {{1}, {2}, {3}}
      local f0, f1, f2 = fun(t1), fun(t1, 'shallow'), fun(t2, 'deep')
      assert.is.equal(t1, f0.bound)
      assert.is_not.equal(t1, f1.bound)
      assert.is.same(t1, f1.bound)
      assert.is_not.equal(t2, f2.bound)
      assert.is_not.equal(t2[1], f2.bound[1])
      assert.is.same(t2, f2.bound)
    end)
  end)

  describe('.strfn', function()
    it('should only accept strings', function()
      assert.has.error(function() Fun.strfn(nil) end)
      assert.has.error(function() Fun.strfn(1) end)
      assert.has_no.error(function() Fun.strfn '->' end)
    end)
    it('should throw an error if the string is not well formatted', function()
      assert.has.error(function() Fun.strfn '' end)
      assert.has.error(function() Fun.strfn 'x' end)
      assert.has.error(function() Fun.strfn 'x return x' end)
      assert.has.error(function() Fun.strfn 'x => x' end)
      assert.has_no.error(function() Fun.strfn '->' end)
      assert.has_no.error(function() Fun.strfn 'x, y -> x + y' end)
      assert.has_no.error(function() Fun.strfn 'x, y, ... -> print(x + y, ...)' end)
    end)
    it('should propagate syntax errors', function()
      assert.has.error(function() Fun.strfn 't -> table.concat(t' end)
      assert.has.error(function() Fun.strfn 't -> for k, v in pairs(t) end' end)
    end)
    it('should accept any number of parameters', function()
      assert.is.equal(Fun.strfn '-> 0'(), 0)
      assert.is.equal(Fun.strfn '->'(), nil)
      assert.is.equal(Fun.strfn 'x -> x + 1'(1), 2)
      assert.is.equal(Fun.strfn 'x, y -> x + y'(1, 2), 3)
      assert.is.equal(Fun.strfn 'x, y, z -> x + y + z'(1, 2, 3), 6)
      assert.is.equal(Fun.strfn '... -> table.concat({...}, ", ")'(1, 2, 3),
        '1, 2, 3')
      local f = Fun.strfn 'a, ... -> a .. ": " .. table.concat({...}, ", ")'
      assert.is.equal(f('label', 1, 2, 3), 'label: 1, 2, 3')
    end)
    it('should accept a single upvalue', function()
      assert.is.equal(Fun.strfn('a -> a + _', 1)(2), 3)
      assert.is.equal(Fun.strfn('a -> a + _[1] + _[2] + _[3]', {1, 2, 3})(-1), 5)
      local f = Fun.strfn('name -> _.fmt:format(name)', {fmt = 'Hello, %s!'})
      assert.is.equal(f('World'), 'Hello, World!')
    end)
  end)

  describe('.gen', function()
    it('should only accept functions', function()
      assert.has.error(function() Fun.gen(nil) end)
      assert.has.error(function() Fun.gen(1) end)
      assert.has_no.error(function() Fun.gen(function() end) end)
    end)
    it('should act like a generic for construct', function()
      local lines = {'this', 'file', 'has', 'five', 'lines'}
      local file = io.open('tmp_spec', 'w')
      file:write(table.concat(lines, '\n'))
      file:close()
      assert.is.same(Fun.gen(io.lines('tmp_spec')):get(), lines)
      assert.is.same(Fun.gen(('just some words'):gmatch '%w+'):get(),
        {'just', 'some', 'words'})
      assert.is.same(Fun.gen(('the initials'):gmatch '((%w)%w*)'):get(),
        {{'the', 't'}, {'initials', 'i'}})
      os.remove('tmp_spec')
    end)
  end)

  describe('.range', function()
    it('should only accept numbers', function()
      assert.has.error(function() Fun.range(nil) end)
      assert.has.error(function() Fun.range(1, 'a') end)
      assert.has.error(function() Fun.range(1, 3, 'a') end)
      assert.has.error(function() Fun.range '' end)
      assert.has.error(function() Fun.range(function() end) end)
      assert.has_no.error(function() Fun.range(1) end)
      assert.has_no.error(function() Fun.range(1, 10) end)
      assert.has_no.error(function() Fun.range(1, 10, 2) end)
    end)
    it('should support finite ranges', function()
      assert.is.same(fun(1, 3):get(), {1, 2, 3})
      assert.is.same(fun(1, 6, 2):get(), {1, 3, 5})
      assert.is.same(fun(1, -1):get(), {1, 0, -1})
    end)
    it('should support infinite ranges', function()
      assert.is.same(fun(1):take(3):get(), {1, 2, 3})
      assert.is.same(fun(1, nil, 2):take(3):get(), {1, 3, 5})
      assert.is.same(fun(1, nil, -1):take(3):get(), {1, 0, -1})
      assert.is.same(fun(1, nil, -2):take(3):get(), {1, -1, -3})
    end)
  end)

  describe(':next', function()
    it('should return a <key, val> pair, or nil if ended', function()
      local t = fun {'a', 'b'}
      local k, v = t:next()
      assert.is.equal(k, 1)
      assert.is.equal(v, 'a')
      k, v = t:next()
      assert.is.equal(k, 2)
      assert.is.equal(v, 'b')
      k, v = t:next()
      assert.is.equal(k, nil)
      assert.is.equal(v, nil)
    end)
    it('should propagate internal errors in transformations', function()
      local t = fun {'a', 'b'}:map(function(v) return v + 1 end)
      assert.has.error(function() t:next() end)
    end)
    it('should cache calculated values', function()
      local t = fun {'a', 'b'}
      local k, v = t:next()
      assert.is.equal(v, t.cache[k])
      k, v = t:next()
      assert.is.equal(v, t.cache[k])
    end)
  end)
end)
