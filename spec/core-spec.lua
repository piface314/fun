describe('Fun', function()
  local fun, Fun

  setup(function()
    fun = require '.init'
    Fun = require '.core'
  end)

  describe('.is', function()
    it('should return true only for Fun objects', function()
      assert.is.True(Fun.is(fun {}))
      assert.is.False(Fun.is({}))
      assert.is.False(Fun.is(nil))
      assert.is.False(Fun.is(1))
    end)
  end)

  describe('.bind', function()
    it('should accept tables', function()
      assert.has_no.errors(function() Fun.bind {} end)
      assert.has.error(function() Fun.bind(nil) end)
      assert.has.error(function() Fun.bind(1) end)
      assert.has.error(function() Fun.bind(true) end)
      assert.has.error(function() Fun.bind('1') end)
    end)
    it('should do a copy of the table if requested', function()
      local t1, t2 = {1, 2, 3}, {{1}, {2}, {3}}
      local f0, f1, f2 = fun(t1), fun(t1, 'shallow'), fun(t2, 'deep')
      assert.is.equal(t1, f0.bound)
      assert.is_not.equal(t1, f1.bound)
      assert.is.same(t1, f1.bound)
      assert.is_not.equal(t2, f2.bound)
      assert.is_not.equal(t2[1], f2.bound[1])
      assert.is.same(t2, f2.bound)
    end)
  end)

  describe(':next', function()
    it('should return a <key, val> pair, or nil if ended', function()
      local t = fun {'a', 'b'}
      local k, v = t:next()
      assert.is.equal(k, 1)
      assert.is.equal(v, 'a')
      k, v = t:next()
      assert.is.equal(k, 2)
      assert.is.equal(v, 'b')
      k, v = t:next()
      assert.is.equal(k, nil)
      assert.is.equal(v, nil)
    end)
    it('should propagate internal errors in transformations', function()
      local t = fun {'a', 'b'}:map(function(v) return v + 1 end)
      assert.has.error(function() t:next() end)
    end)
    it('should cache calculated values', function()
      local t = fun {'a', 'b'}
      local k, v = t:next()
      assert.is.equal(v, t.cache[k])
      k, v = t:next()
      assert.is.equal(v, t.cache[k])
    end)
  end)
end)
